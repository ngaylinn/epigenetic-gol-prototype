"""Run all experiments and rebuild result summaries to embed in readme.md.

This project is a demo of a self-optimizing genetic algorithm. The readme file
contains an overview of the experiment's purpose, design, and results. The
graphs, images, and videos referenced by the readme are all produced by running
this script and stored in the output directory.

Here is an overview of the files generated by this script:
- output
    - compare_phenotypes
        - <fitness_goal>
            * <genome_config>_fitness.png
            * <genome_config>_best.gif
            * summary.png
        - simulation_videos
            * <simulation_id>_run.gif
        * experiment_data.pickle
TODO: Document the outer loop experiments.
"""

import os
import pickle
import random
import statistics

import matplotlib.pyplot as plt
import numpy as np

import experiments
import genome
import genome_configuration
import gol_simulation


def make_title(name):
    """Format a camel case name string as a display title."""
    return name.replace('_', ' ').title()


def genome_config_samples():
    """Save samples of phenotypes made with different genome configurations."""
    path = 'output/genome_config_samples'
    if os.path.exists(path):
        return
    os.makedirs(path)
    sample_dict = {}
    flat_samples = []
    for genome_name, genome_config in genome.EXPERIMENT_CONFIGS.items():
        new_samples = [
            gol_simulation.GameOfLifeSimulation(genome.Genotype(genome_config))
            for _ in range(6)]
        sample_dict[genome_name] = new_samples
        flat_samples.extend(new_samples)
    gol_simulation.simulate(flat_samples, [0])
    for genome_name, samples in sample_dict.items():
        for index, simulation in enumerate(samples):
            simulation.save_video(f'{path}/{genome_name}_{index}.gif')


def trials_summary(trial_series, title):
    # Generate a chart of all trials in this configuration.
    fig = plt.figure()
    fig.suptitle(title)
    axis = fig.add_subplot()
    generations = list(range(experiments.NUM_SIMULATION_GENERATIONS))
    for trial_index, data_series in enumerate(trial_series):
        axis.plot(generations, data_series, label=f'Trial {trial_index + 1}')
    axis.legend()
    return fig


def compare_phenotypes():
    """Compare the performance of genome configurations on fitness goals."""
    path = 'output/compare_phenotypes'
    os.makedirs(path, exist_ok=True)

    generations = list(range(experiments.NUM_SIMULATION_GENERATIONS))

    study = experiments.compare_phenotypes_study

    for fitness_name, more_experiments in study.items():
        os.makedirs(f'{path}/{fitness_name}', exist_ok=True)

        fitness_summary_fig = plt.figure(figsize=(6, 3))
        fitness_summary_fig.suptitle(
            f'Phenotype Performance for {make_title(fitness_name)}')
        regression_axis = fitness_summary_fig.add_subplot(1, 2, 1)
        regression_axis.set_title('Median Fitness Trajectory')

        #sample_simulations = []
        max_fitness_by_genome = []
        genome_names = []

        for genome_name, run_experiment in more_experiments.items():
            print(f'Compare Phenotypes ({fitness_name} x {genome_name})')
            state_filename = f'{path}/{fitness_name}/{genome_name}_state.pickle'
            data = run_experiment(state_filename)
            #sample_simulations.extend(data['sample_simulations'])
            trial_series = data['trial_series']
            best_simulation = data['best_simulation']

            gol_simulation.record_single_video(
                best_simulation,
                f'{path}/{fitness_name}/{genome_name}_best.gif')

            # Generate a chart showing the fitness trajectory across all the
            # trials in this experiment.
            trials_summary(
                trial_series,
                f'{make_title(fitness_name)} x {make_title(genome_name)}'
            ).savefig(
                f'{path}/{fitness_name}/{genome_name}_fitness.png')
            genome_names.append(genome_name)

            # Generate a chart comparing median fitness trajectories
            median_fitness_series = list(
                map(statistics.median, zip(*trial_series)))
            median_slope, median_intercept = statistics.linear_regression(
                generations, median_fitness_series)
            median_regression_series = [
                median_intercept + x * median_slope for x in generations]
            regression_axis.plot(
                generations, median_regression_series,
                label=make_title(genome_name))
            regression_axis.legend()

            # For each genome_config, track the max fitness it achieved across
            # all trials and its name for the aggregate box plot below.
            max_fitness_by_genome.append(list(map(max, trial_series)))

        # Generate a boxplot summarizing max fitness across trials.
        fitness_axis = fitness_summary_fig.add_subplot(1, 2, 2)
        fitness_axis.set_title('Best Fitness Across Trials')
        labels = [make_title(name) for name in genome_names]
        fitness_axis.boxplot(max_fitness_by_genome, labels=labels)
        fitness_summary_fig.savefig(f'{path}/{fitness_name}/summary.png')
        plt.close('all')


def visualize_genome_config(genome_config):
    def format_floats(values):
        return [f'{value:0.4f}' for value in values]

    def get_color(value, baseline, max_value):
        # 0 is a special value, indicating a fixed gene (static)
        if value == 0.0:
            return (0, 0, 0, 1)
        # If the value is smaller than the baseline, show it on a gray scale
        # going from white (baseline) to black (static)
        if value <= baseline:
            return plt.cm.binary(1 - value / baseline)
        # If the value is greater than the baseline, show it on a scale going
        # from white (baseline) to deep blue (max value)
        return plt.cm.Blues(value / max_value)

    def get_colors(values, baseline, max_value):
        return [get_color(value, baseline, max_value) for value in values]

    global_mutation_rate = genome_config.global_mutation_rate
    global_crossover_rate = genome_config.global_crossover_rate
    gene_mutation_rates = {}
    for gene_name, gene_config in genome_config.gene_configs.items():
        gene_mutation_rates[gene_name] = [
            gene_config.mutation_rate(vector, global_mutation_rate[vector])
            for vector in genome_configuration.FitnessVector]
    text = []
    colors = []
    text.append(format_floats(global_mutation_rate))
    colors.append(get_colors(global_mutation_rate,
                             genome_configuration.DEFAULT_MUTATION_RATE,
                             genome_configuration.MAX_MUTATION_RATE))
    text.append(format_floats(global_crossover_rate))
    colors.append(get_colors(global_crossover_rate,
                             genome_configuration.DEFAULT_CROSSOVER_RATE,
                             1))
    short_names = {
        'seed': 'Seed',
        'stamp': 'Stamp',
        'stamp_offset': 'StpOff',
        'repeat_mode': 'RptMod',
        'repeat_offset': 'RptOff',
        'mirror': 'Mirror'
    }
    row_labels = ['GlbMut', 'GlbCxr']
    for gene_name, gene_config in genome_config.gene_configs.items():
        mutation_rates = gene_mutation_rates[gene_name]
        text.append(format_floats(mutation_rates))
        colors.append(get_colors(mutation_rates,
                                 genome_configuration.DEFAULT_MUTATION_RATE,
                                 genome_configuration.MAX_MUTATION_RATE))
        row_labels.append(short_names[gene_name])
    fig, axis = plt.subplots()
    fig.patch.set_visible(False)
    axis.axis('off')
    axis.axis('tight')
    axis.table(cellText=text,
               cellColours=colors,
               rowLabels=row_labels,
               colLabels=['▼', '=', '▲'],
               colWidths=[.1, .1, .1],
               loc='center')
    fig.tight_layout()
    return fig


def evolve_genome_configuration():
    path = 'output/evolve_genome_configuration'
    os.makedirs(path, exist_ok=True)

    study = experiments.evolve_genome_study
    for fitness_name, more_experiments in study.items():
        os.makedirs(f'{path}/{fitness_name}', exist_ok=True)
        for genome_fitness_name, run_experiment in more_experiments.items():
            print(f'Evolve GenomeConfig ({fitness_name} x {genome_fitness_name})')
            state_filename = f'{path}/{fitness_name}/{genome_fitness_name}_state.pickle'
            data = run_experiment(state_filename)
            #sample_simulations = data['sample_simulations']
            fitness_series = data['fitness_series']
            best_genome_config = data['best_config']
            trial_series = data['best_trials']
            best_simulation = data['best_simulation']

            os.makedirs(f'{path}/{fitness_name}', exist_ok=True)
            generations = list(range(experiments.NUM_GENOME_GENERATIONS))
            fig = plt.figure()
            axis = fig.add_subplot()
            axis.plot(generations, fitness_series,
                      label=make_title(fitness_name))
            axis.legend()
            fig.savefig(f'{path}/{fitness_name}/{genome_fitness_name}_summary.png')

            pickle_filename = f'{path}/{fitness_name}/{genome_fitness_name}_best.pickle'
            with open(pickle_filename, 'wb') as file:
                pickle.dump(best_genome_config, file)
            visualize_genome_config(best_genome_config).savefig(
                f'{path}/{fitness_name}/{genome_fitness_name}_best.png')

            trials_summary(
                trial_series, f'{make_title(fitness_name)}'
            ).savefig(f'{path}/{fitness_name}/{genome_fitness_name}_best_trials.png')

            gol_simulation.record_single_video(
                best_simulation,
                f'{path}/{fitness_name}/{genome_fitness_name}_best_sim.gif')
            plt.close('all')


def main():
    """Actually rebuild all the files in the output directory."""
    # This project uses Python's RNG for almost everything, but there are a few
    # operations in the gene_types module that get a major performance boost
    # from using Numpy's RNG instead. We want pseudo-random behavior, but we
    # also want consistent output from run to run to facilitate debugging, so
    # we seed both RNGs before running the experiments.
    np.random.seed(42)
    random.seed(42)
    # Capture sample phenotypes to help explain what the genome configurations
    # do and what the experiments are actually testing.
    # TODO: Re-enable
    # genome_config_samples()
    # Run the phase one experiments, comparing the performance of all the
    # predefined genome configurations on all the fitness goals.
    # TODO: Re-enable
    # compare_phenotypes()
    evolve_genome_configuration()


if __name__ == '__main__':
    main()
